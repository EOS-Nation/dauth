---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by cbillett.
--- DateTime: 2020-02-05 8:57 a.m.
---

redis.replicate_commands()

--- Utilities

local function slice(tbl, first, last, step)
    local sliced = {}

    for i = first or 1, last or #tbl, step or 1 do
        sliced[#sliced + 1] = tbl[i]
    end

    return sliced
end

local function computeCurrentPeriodConsumption(windowSize)
    local keys = slice(KEYS, 5, 5 + windowSize)
    local values = redis.call("MGET", unpack(keys))
    local sum = 0
    for index, value in ipairs(values) do
        local v = tonumber(value)
        if v ~= nil then
            sum = sum + v
        end
    end
    return sum
end

--- KEY DEFINITIONS
local userPeriodConsumedDoc = KEYS[1]
local blackListKey = KEYS[2]
local blackListVersionKey = KEYS[3]
local userMinutelyDocConsumptionKey = KEYS[4]
local burstKey = KEYS[5]

--- SCRIPT INPUTS
local allocatedDocumentCount = tonumber(ARGV[1])
local consumeDocument = tonumber(ARGV[2])
local endOfWindowTimeStamp = tonumber(ARGV[3])
local blockDuration = tonumber(ARGV[4])
local windowSizeMinutes = tonumber(ARGV[5])
local burstMultiplier = tonumber(ARGV[6])
local burstWindowMinutes = tonumber(ARGV[7])

--print("userPeriodConsumedDoc:" .. userPeriodConsumedDoc)
--print("allocatedDocumentCount:" .. allocatedDocumentCount)
--print("consumeDocument:" .. consumeDocument)
--print("endOfDayTimeStamp:" .. endOfDayTimeStamp)
--- --------------------------------------------------
--- The meat!
--- --------------------------------------------------
if consumeDocument == 0 then
    return 0
end

--- Skip unlimited access
if allocatedDocumentCount == 0 then
    -- unlimited access
    return "unlimited"
end

-- Skip already blacklisted keys
if redis.call("EXISTS", blackListKey) == 1 then
    return "already bl"
end

--- Minutely consumption handling
if redis.call("INCRBY", userMinutelyDocConsumptionKey, consumeDocument) == consumeDocument then
    redis.call("EXPIRE", userMinutelyDocConsumptionKey, 60 * windowSizeMinutes)
end

--- Check consumption over the current window
local periodConsumeDocument = redis.call("INCRBY", userPeriodConsumedDoc, consumeDocument)
if periodConsumeDocument == consumeDocument then
    -- We have a new currentPeriodConsumption key
    periodConsumeDocument = computeCurrentPeriodConsumption(windowSizeMinutes)
    redis.call("SET", userPeriodConsumedDoc, periodConsumeDocument)
    redis.call("EXPIREAT", userPeriodConsumedDoc, endOfWindowTimeStamp)
end

if periodConsumeDocument > (allocatedDocumentCount * windowSizeMinutes) then
    -- if the consumed document count is larger than the burst size or the key has already used it's burst we blacklist the key
    -- burst is allowed once for an evaluated window within the given burst window
    if periodConsumeDocument > (allocatedDocumentCount * windowSizeMinutes * burstMultiplier)
            or (redis.call("EXISTS", burstKey) == 1 and redis.call("TTL", burstKey) < ((burstWindowMinutes * 60) - (windowSizeMinutes * 60 * 2))) then
        redis.call("SETEX", blackListKey, blockDuration, "total doc exceeded")
        redis.call("INCR", blackListVersionKey)
        return "bl"
    end
    -- burst is allowed, add an expiring burst key if not already exists
    if redis.call("EXISTS", burstKey) == 0 then
        redis.call("SETEX", burstKey, burstWindowMinutes * 60, "burst")
    end

    return "burst"
end

return "all good"
